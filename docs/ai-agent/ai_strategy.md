Отличный вопрос! Это ключевой момент в поддержке и развитии любого проекта. Когда вы переходите от создания к поддержке и добавлению фич, роли и их фокус должны смещаться с **создания** на **анализ и интеграцию**.

Главная цель — чтобы новый код не нарушал существующую архитектуру, не дублировал функциональность и соответствовал принципам DRY (Don't Repeat Yourself) и KISS (Keep It Simple, Stupid).

Вот какие роли и их задачи критически важны на этапе дополнения проекта:

---

### 1. Агент-аналитик (с фокусом на Impact Analysis)

Его задача — не просто понять новое требование, а **проанализировать его impact на существующую систему**.

**Что он должен сделать:**

- **Сравнить новую фичу с существующим функционалом:** "А нет ли у нас уже похожего метода/сервиса/модуля?"
- **Выявить потенциальные конфликты:** "Эта новая фича потребует изменения API, который уже используют другие сервисы."
- **Определить точки расширения:** "Вместо того чтобы писать новый код, мы можем расширить класс X, потому что он уже делает нечто подобное."
- **Сформулировать уточняющие вопросы:** "Вы сказали 'добавить кэширование'. Какой тип кэша предпочтителен? У нас уже используется Redis в проекте. Используем его?"

**Пример промта для Claude:**

> Ты — технический аналитик. Проанализируй описание новой функциональности "[Опишите фичу]" в контексте существующего проекта.
> **Существующий проект:** [Опишите кратко суть проекта или вставьте ключевые части кода/архитектуры].
>
> 1.  **Проведи анализ воздействия (Impact Analysis):** Какие модули, классы или API endpoints затронет новая функциональность?
> 2.  **Найди возможности для повторного использования:** Есть ли в коде похожие функции, которые можно расширить или переиспользовать?
> 3.  **Выяви риски:** Какие потенциальные конфликты или проблемы это может вызвать?
> 4.  **Задай уточняющие вопросы:** Какой информации не хватает для точной оценки задачи?
>     Предоставь ответ в виде структурированного отчета.

---

### 2. Агент-архитектор (с фокусом на целостность архитектуры)

Его задача — **не выбрать стек, а оценить, как новая фича впишется в текущую архитектуру**, и предложить наименее затратный и наиболее чистый путь интеграции.

**Что он должен сделать:**

- **Оценить соответствие принципам проекта:** "Мы используем Clean Architecture, поэтому новую логику нужно добавлять в слой use cases, а не в контроллер."
- **Предложить шаблон проектирования:** "Для этого лучше подойдет Стратегия (Strategy), а не гигантский условный оператор."
- **Запретить изобретение велосипедов:** "У нас уже есть модуль `utils/helpers.py` для таких функций. Не создавай новый файл."
- **Определить контракты и интерфейсы:** "Новый сервис должен реализовывать этот интерфейс, чтобы быть совместимым с остальной системой."

**Пример промта для Claude:**

> Ты — software architect. Оцени предложение по новой функциональности и предоставленную существующую архитектуру на предмет целостности.
> **Предложение от аналитика:** [Вставь выводы агента-аналитика]
> **Кодовая база/Архитектура:** [Опиши или приложи ключевые части]
>
> 1.  **Предложи конкретный путь интеграции:** В какие именно модули/файлы нужно вносить изменения? Какой шаблон проектирования использовать?
> 2.  **Соблюди принципы архитектуры:** Предложи решение, которое соответствует текущей архитектуре (например, Clean Architecture, MVC и т.д.).
> 3.  **Избегай дублирования:** Укажи, какой уже существующий код можно переиспользовать.
> 4.  **Нарисуй схему взаимодействия:** Как новые компоненты будут взаимодействовать со старыми?
>     Ответь в формате "Архитектурное решение".

---

### 3. Агент-кодер (с фокусом на рефакторинг и паттерны)

Его задача — **не написать код с нуля, а грамотно встроить новую функциональность в существующую кодовую базу**, часто через рефакторинг.

**Что он должен сделать:**

- **Модифицировать существующий код:** Внести минимальные изменения в текущие модули для поддержки новой фичи.
- **Применить рефакторинг:** "Этот метод стал слишком большим, нужно выделить общую логику в отдельный класс."
- **Следовать code style:** Соблюдать отступы, именование, стиль комментариев, принятые в проекте.
- **Избегать copy-paste:** Если код похож на существующий, значит, нужно абстрагировать логику, а не копировать.

**Пример промта для Claude:**

> Ты — senior-разработчик. Твоя задача — реализовать новую функциональность, **интегрировав ее в существующий код**, а не написав с нуля. Сфокусируйся на рефакторинге и переиспользовании.
>
> **Архитектурное решение:** [Вставь решение архитектора]
> **Существующий код (важные части):** [Приложи код файлов, которые нужно изменить]
>
> 1.  **Внеси изменения прямо в предоставленный код.** Покажи итоговый вид измененных файлов.
> 2.  **Выдели общую логику через рефакторинг,** если это необходимо.
> 3.  **Строго соблюдай code style существующего кода** (отступы, именование, импорты).
> 4.  **Не создавай новые файлы без крайней необходимости.**
> 5.  **Прокомментируй только самые сложные места, где логика неочевидна.**

---

### 4. Агент-ревизор/Верификатор (с фокусом на регрессию и технический долг)

Это самая важная роль при добавлении фич. Его задача — **поймать любую избыточность, ухудшение архитектуры и потенциальный регресс**.

**Что он должен сделать:**

- **Сравнить код ДО и ПОСЛЕ:** Убедиться, что новая фича не добавила дублирования.
- **Проверить, не был ли нарушен принцип Open/Closed:** "Мы расширили функциональность, а не модифицировали существующий код?"
- **Оценить рост технического долга:** "Это решение усложнило систему? Можно ли было сделать проще?"
- **Запустить "гипотетические" тесты:** "А что если вызвать этот новый метод с такими параметрами? Не сломает ли это старую логику?"

**Пример промта для Claude:**

> Ты — главный инженер, ответственный за качество кода. Сравни два варианта кода: исходный и с добавленной новой функциональностью.
>
> **ИСХОДНЫЙ КОД:** [Приложи исходный код]
> **НОВЫЙ КОД:** [Приложи код, полученный от кодера]
> **Требования к фиче:** [Опиши фичу]
>
> 1.  **Найди избыточность:** Укажи на любой новый код, который дублирует уже существующую логику.
> 2.  **Оцени регрессию:** Могли ли изменения случайно сломать существующий функционал?
> 3.  **Оцени архитектурную чистоту:** Стал ли код после изменений проще или сложнее? Не появилось ли "дурных запахов" (code smells)?
> 4.  **Дай вердикт:** Можно ли мержить этот код или его нужно переработать? Предложи конкретные исправления.

### Ключевой вывод

При добавлении фич **ваша роль как диспетчера становится еще важнее**. Вы должны предоставлять агентам **контекст существующего кода и требований**. Чем больше контекста вы дадите (вставляя куски ключевого кода, описывая архитектуру), тем точнее и качественнее будет результат, и тем меньше шансов получить "солянку" и избыточность.

**Идеальный workflow:**

1.  **Аналитик** (с контекстом проекта) оценивает impact.
2.  **Архитектор** (с контекстом кода) предлагает путь интеграции.
3.  **Кодер** (с контекстом файлов) вносит изменения.
4.  **Ревизор** (сравнивая старый и новый код) ставит финальное approve.

Это требует больше усилий, но результат — чистый, поддерживаемый код, а не хаос.
