# Архитектура ролей и доступа

> **Версия:** 1.0  
> **Создано:** 4 июля 2025  
> **Статус:** Активный архитектурный документ

## Обзор

Данный документ описывает архитектуру системы ролей и доступа в рамках монорепозитория exchanger. Система построена на принципах разделения ответственности, модульности и расширяемости.

## Архитектурные принципы

### 1. Принцип разделения приложений по назначению

- **`apps/web`** — операционное приложение для работы операторов и саппорта
- **`apps/admin-panel`** — административное приложение исключительно для администраторов
- **Четкое разделение** — каждое приложение имеет свою аудиторию и функции

### 2. Permission-based система доступа

```typescript
// Структура разрешений
interface Permission {
  resource: string; // например, 'orders', 'users', 'monitoring'
  action: string; // например, 'read', 'write', 'delete', 'approve'
  scope?: string[]; // например, ['own', 'team', 'all']
}

// Привязка ролей к разрешениям
interface RolePermissions {
  [roleName: string]: Permission[];
}
```

### 3. Модульная архитектура UI

- **Условный рендеринг** компонентов на основе разрешений
- **Graceful degradation** — скрытие недоступных функций вместо ошибок
- **Композитные компоненты** с проверкой доступа на уровне props

### 4. Расширяемые API эндпоинты

- **Отдельные роутеры** для каждой группы ролей
- **Middleware для проверки доступа** на уровне роутов
- **Конфигурируемые права** через внешние источники данных

## Определение ролей

### Администраторы (Admin Panel только)

**Местоположение:** `apps/admin-panel`

**Базовые scope:**

- Полное управление системой
- Управление пользователями и их ролями
- Доступ к системным настройкам
- Мониторинг всех операций
- Финансовое управление

**Архитектурные особенности:**

- Отдельное приложение с независимой аутентификацией
- Расширенные средства мониторинга и аналитики
- Доступ к критически важным системным операциям

### Операторы (Web App)

**Местоположение:** `apps/web`

**Базовые scope:**

- Обработка заявок на обмен
- Взаимодействие с клиентами
- Мониторинг операций в рамках смены
- Базовая отчетность

**Возможные расширения scope:**

- Управление лимитами (в рамках полномочий)
- Эскалация сложных случаев
- Доступ к расширенной аналитике
- Работа с VIP-клиентами

### Саппорт (Web App)

**Местоположение:** `apps/web`

**Базовые scope:**

- Консультации клиентов
- Решение технических вопросов
- Доступ к базе знаний
- Создание тикетов

**Возможные расширения scope:**

- Управление FAQ и документацией
- Эскалация в техподдержку
- Работа с претензиями
- Базовая модерация

## Техническая реализация

### Структура констант ролей

```typescript
// packages/constants/src/user.ts
export const USER_ROLES = {
  ADMIN: 'admin', // Только admin-panel
  OPERATOR: 'operator', // apps/web
  SUPPORT: 'support', // apps/web
} as const;

export const APP_SCOPE = {
  ADMIN_PANEL: 'admin-panel',
  WEB_APP: 'web',
} as const;

// Маппинг ролей к приложениям
export const ROLE_TO_APP_MAPPING = {
  [USER_ROLES.ADMIN]: [APP_SCOPE.ADMIN_PANEL],
  [USER_ROLES.OPERATOR]: [APP_SCOPE.WEB_APP],
  [USER_ROLES.SUPPORT]: [APP_SCOPE.WEB_APP],
} as const;
```

### Middleware для проверки доступа

```typescript
// apps/web/src/server/trpc/middleware/auth.ts
export const roleMiddleware = (allowedRoles: UserRole[]) => {
  return middleware(async ({ ctx, next }) => {
    if (!ctx.session?.user?.role) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }

    if (!allowedRoles.includes(ctx.session.user.role)) {
      throw new TRPCError({ code: 'FORBIDDEN' });
    }

    return next({ ctx });
  });
};

// Специализированные middleware
export const operatorOnly = roleMiddleware([USER_ROLES.OPERATOR]);
export const supportOnly = roleMiddleware([USER_ROLES.SUPPORT]);
export const operatorAndSupport = roleMiddleware([USER_ROLES.OPERATOR, USER_ROLES.SUPPORT]);
```

### Структура API роутеров

```typescript
// apps/web/src/server/trpc/routers/
├── index.ts              // Главный роутер
├── operator.ts           // Роутер для операторов
├── support.ts            // Роутер для саппорта
├── shared.ts             // Общие эндпоинты для operator + support
└── admin.ts              // ВНИМАНИЕ: для admin-panel, не для web app
```

### Компоненты с проверкой доступа

```typescript
// Пример permission-based компонента
interface ProtectedComponentProps {
  requiredRole?: UserRole[];
  requiredPermission?: Permission;
  fallback?: React.ReactNode;
  children: React.ReactNode;
}

export const ProtectedComponent: React.FC<ProtectedComponentProps> = ({
  requiredRole,
  requiredPermission,
  fallback = null,
  children
}) => {
  const { user } = useSession();

  if (requiredRole && !requiredRole.includes(user?.role)) {
    return fallback;
  }

  if (requiredPermission && !hasPermission(user, requiredPermission)) {
    return fallback;
  }

  return <>{children}</>;
};
```

## Архитектурные рекомендации для расширения

### 1. Добавление новых ролей

**Алгоритм:**

1. Определить scope и назначение роли
2. Выбрать целевое приложение (web vs admin-panel)
3. Добавить константу в `packages/constants/src/user.ts`
4. Обновить middleware и создать специализированные проверки
5. Создать или обновить соответствующие роутеры
6. Обновить UI компоненты с учетом новой роли

### 2. Расширение существующих scope

**Принципы:**

- Сохранение обратной совместимости
- Использование feature flags для постепенного внедрения
- Четкое документирование изменений в scope
- Тестирование на всех уровнях (middleware, API, UI)

### 3. Permission-based контроль

**Рекомендуемая структура:**

```typescript
// Будущая расширенная система разрешений
interface ExtendedPermission {
  resource: string;
  actions: string[];
  conditions?: {
    timeRange?: [string, string];
    locationRestriction?: string[];
    amountLimit?: number;
  };
}
```

### 4. Интеграция с внешними системами

**Архитектурный подход:**

- Использование адаптеров для внешних источников ролей
- Кэширование разрешений с TTL
- Fallback механизмы при недоступности внешних систем
- Логирование всех изменений в правах доступа

## Best Practices

### 1. Безопасность

- **Принцип наименьших привилегий** — предоставлять минимально необходимые права
- **Регулярная ротация** разрешений и пересмотр scope
- **Аудит доступа** — логирование всех действий с привилегиями
- **Fail-safe подход** — при ошибке запрещать доступ, а не разрешать

### 2. Производительность

- **Кэширование** проверок разрешений
- **Batch-операции** для множественных проверок
- **Lazy loading** компонентов с тяжелыми проверками доступа
- **Предварительная загрузка** базовых разрешений

### 3. Пользовательский опыт

- **Graceful degradation** — скрытие недоступных функций
- **Информативные сообщения** о недостатке прав
- **Прогрессивное раскрытие** функций по мере роста разрешений
- **Контекстные подсказки** о доступных действиях

### 4. Мониторинг и отладка

- **Детальное логирование** решений о доступе
- **Метрики использования** разрешений
- **Инструменты отладки** для разработчиков
- **Алерты на аномальную активность** доступа

## Миграционная стратегия

### Этап 1: Базовая инфраструктура

- Создание констант и базовых типов
- Реализация middleware для проверки ролей
- Обновление существующих роутеров

### Этап 2: UI адаптация

- Внедрение ProtectedComponent
- Обновление навигации с учетом ролей
- Адаптация форм и действий

### Этап 3: Расширенные возможности

- Внедрение permission-based системы
- Интеграция с внешними источниками ролей
- Расширенный мониторинг и аудит

### Этап 4: Оптимизация

- Кэширование и производительность
- A/B тестирование UX решений
- Финальная настройка безопасности

## Заключение

Представленная архитектура ролей и доступа обеспечивает:

- **Четкое разделение** ответственности между приложениями
- **Гибкость расширения** для будущих потребностей бизнеса
- **Безопасность и контроль** доступа на всех уровнях
- **Качественный UX** с учетом роли пользователя

Архитектура спроектирована с учетом принципов SOLID, DRY и следует лучшим практикам enterprise-разработки в экосистеме TypeScript/React/tRPC.
