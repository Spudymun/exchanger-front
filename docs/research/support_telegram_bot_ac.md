# Support — Telegram-only (production-ready) — Acceptance Criteria (AC)

**Цель:** добавить в существующее приложение простой production-ready саппорт через Telegram-бота. Ничего другого (email, livechat) не реализуем — только Telegram.

Документ описывает объём, функциональные и нефункциональные требования и критерии приёмки (AC). Этот файл — спецификация для разработчика/ИИ-агента: точные условия, ожидаемое поведение и проверяемые сценарии.

---

## 1. Область и ограничения

- Поддерживается только Telegram (бот). Веб-интерфейс клиента приложения будет содержать одну кнопку/ссылку, открывающую в новом окне чат с ботом или показывающую инструкцию, как написать боту.
- Бот действует как «приёмник» входящих сообщений от пользователей и как оповещатель для операторов (операторы — в Telegram, отдельный операторский чат/группа или приватные аккаунты). Внешняя CRM/тикет-система — вне зоны задачи.
- Решение должно быть простым, устойчивым к ошибкам, безопасным для продакшна и легко разворачиваемым.

---

## 2. Требуемые от заказчика данные (explicit — без предположений)

Перед началом разработчик / агент должен получить:
1. **Telegram Bot Token** (BotFather) — строка токена.
2. **Список Telegram ID операторов** (или ID группы/канала) — куда пересылать уведомления. Если список не предоставлен, реализовать возможность задавать/изменять их через конфиг/переменные окружения.
3. Решение для хостинга бота: **webhook** (предпочтительный вариант для продакшна) или **long polling**. Если webhook — предоставить публичный HTTPS URL / сертификат/домен или настроить через reverse proxy. Если не предоставлено — по умолчанию задействовать long polling.
4. Доступ к репозиторию кода и CI/CD (или инструкции по деплою).

> Всё, что не входит в этот список — считается явным отсутствием данных и должно быть оформлено как blocker до реализации.

---

## 3. Общие требования качества (non-functional)

1. **Надёжность:** бот должен автоматически восстанавливаться при падении (systemd / process manager / контейнер в k8s + liveness probe).
2. **Безопасность:** токен бота и данные операторов должны храниться в переменных окружения/секретах CI. Никаких токенов в репозитории.
3. **Логирование:** структурированные логи (JSON) с минимумом: timestamp, level, event, user_id (анонимно), message_id, error (если есть). Логи не должны содержать полного текста секретных данных.
4. **Конфигурируемость:** адреса операторских чатов/ID, режим webhook/polling, retry и rate limits — через env vars.
5. **Производительность:** решение должно выдерживать пиковую нагрузку ~100 сообщений в минуту (baseline) с деградацией graceful.
6. **Мониторинг:** бот должен экспортировать метрики: `messages_received_total`, `messages_forwarded_total`, `errors_total`, `uptime_seconds` (Prometheus-compatible или лог-ориентированное решение).
7. **GDPR/Privacy:** если пользователь отправляет персональные данные — системно хранить минимум. По умолчанию бот не сохраняет сообщения в БД, только логи и пересылки. Если сохраняем — явно указать retention policy.

---

## 4. Функциональные требования

### 4.1 Принятие и подтверждение сообщения
- Пользователь пишет боту `@YourBot support` или нажимает ссылку в приложении и начинает чат.
- При первом сообщении бот отвечает приветственной карточкой (см. шаблон ниже) с часами работы, ожиданием ответа и кнопкой `Отправить заявку` (inline-кнопка) и `Старт`.
- Бот присваивает каждой сессии простой **session id** (UUID) и включает его в пересылаемые нотификации оператору (для трассировки).

### 4.2 Пересылка оператору
- Все входящие сообщения (текст, изображения, документы, голосовые) пересылаются в операторский чат (группа/индивидуально) вместе с метаданными: username (если есть), user_id (Telegram numeric id), session id, время.
- Для сообщений с файлами бот пересылает файл и сохраняет временную ссылку в логе; длительное хранение файлов — вне задачи.

### 4.3 Ответ оператора пользователю
- Оператор отвечает в операторском чате, используя reply на пересланное сообщение. Бот должен поймать ответ оператора и переслать его пользователю (one-to-one reply). Ответ оператора должен включать reference на session id и исходное сообщение.
- Если оператор отвечает не через reply, бот игнорирует сообщение и отправляет ответ-напоминание в операторский чат: "Чтобы ответить пользователю, нажмите reply на его пересланное сообщение.".

### 4.4 Статусы и команды
- Команда `/close <session_id>` — закрывает сессию и отправляет пользователю уведомление "Заявка закрыта".
- Команда `/assign <session_id> @operator` — помечает сессию назначенной (реализовать в памяти — in-memory map). Долговременная запись в БД не обязательна, но допускается.

### 4.5 UI-примитивы в веб-приложении
- На фронтенде — кнопка `Поддержка` или ссылка `Чат с поддержкой` (в header/footer). Клик открывает внешний телеграм-линк `https://t.me/<bot_username>` (или `tg://resolve?domain=<bot_username>`), либо всплывает модал с инструкцией и часами работы.
- Вёрстка: простая кнопка, текст: `Написать в поддержку`.

---

## 5. Сообщения / шаблоны (RU / EN)

**Приветствие (RU):**
> Вас приветствует служба поддержки `YourService`. Наш график работы: 09:00–22:00 (Kyiv). Напишите ваше сообщение — оператор ответит, как только освободится.

**Приветствие (EN):**
> Welcome to `YourService` support. Our schedule: 09:00–22:00 (Kyiv). Write your message — an agent will reply as soon as available.

**При пересылке оператору:**
```
[SUPPORT] Новое сообщение
session: <UUID>
from: <username_or_name> (id:<user_id>)
time: <ISO8601>
---
<текст сообщения или метаданные о файле>
```

**При ответе оператору (если reply):**
```
[SUPPORT] Ответ оператора
session: <UUID>
operator: @operator_username
---
<текст ответа>
```

**При закрытии:**
`Ваша заявка <session_id> закрыта. Спасибо, что обратились в поддержку.`

---

## 6. Логика ошибок и retry

- При неуспешной пересылке сообщения оператору — делать 3 попытки с экспоненциальной задержкой (1s, 5s, 20s). После 3 неудач — записать `errors_total++` и отправить алерт в лог/операторский чат.
- При попытке отправить оператору файл, превышающий лимит Telegram API — прислать оператору текстовое уведомление с указанием, что файл слишком большой, и краткую инструкцию для пользователя: "Пришлите файл через облачный сервис и дайте ссылку."

---

## 7. Безопасность и приватность

- Токен хранится только в секрете (env var). В репозитории допускается пример `.env.example` без реального токена.
- Логи не должны раскрывать чувствительные персональные данные (например, полные номера карт). Если такие данные приходят — помечать и обрезать первые/последние 4 символа в логах.
- Доступ к операторскому чату ограничен — список операторских ID хранится в конфиге.

---

## 8. Метрики и мониторинг

Экспорт или логирование метрик (в формате, пригодном для Prometheus/Logstash):
- `messages_received_total` — counter
- `messages_forwarded_total` — counter
- `responses_sent_total` — counter
- `errors_total` — counter
- `uptime_seconds` — gauge

Алерты (примерные):
- `errors_total` > 5 за 5 минут — оповещение в операторский чат (или Slack/another — вне задачи).
- downtime > 1 min — пуш в операторский чат.

---

## 9. Acceptance Criteria (чёткие проверки)

Ниже — атомарные утверждения, которые можно проверить вручную или в автоматизированных тестах. Все пункты должны быть выполнены для принятия задачи.

### AC-1: Приветствие
- GIVEN: пользователь впервые пишет боту
- WHEN: бот получает первое сообщение
- THEN: бот отправляет приветственную карточку (RU/EN в зависимости от языка, либо RU по умолчанию) с кнопкой `Старт`/`Отправить заявку` и session id.

### AC-2: Пересылка сообщения оператору
- GIVEN: пользователь отправляет текстовое сообщение
- WHEN: сообщение приходит к боту
- THEN: бот пересылает сообщение в операторский чат с session id, username/user_id и временем.
- AND: операторский чат получает текст и метаданные, и log содержит запись `messages_forwarded_total++`.

### AC-3: Пересылка файла
- GIVEN: пользователь отправляет файл (документ/картинку/голосовое)
- WHEN: бот получает файл
- THEN: бот пересылает файл (или его ссылку) в операторский чат и логирует событие.
- AND: если файл превышает лимит Telegram API — оператор получает уведомление об ошибке с инструкцией.

### AC-4: Ответ оператора в reply
- GIVEN: оператор отвечает **reply** на пересланное сообщение в операторском чате
- WHEN: бот получает ответ оператора
- THEN: бот пересылает ответ пользователю как обычное сообщение и логирует `responses_sent_total++`.

### AC-5: Игнорирование не-reply ответов оператора
- GIVEN: оператор пишет в операторский чат не через reply
- WHEN: бот получает такое сообщение
- THEN: бот не отправляет это сообщение пользователю и отправляет уведомление в операторский чат с инструкцией "Для ответа нажмите reply на пересланное сообщение".

### AC-6: Команды управления
- GIVEN: оператор отправляет `/close <session_id>`
- WHEN: команда обработана
- THEN: бот помечает сессию как закрытую (in-memory) и отправляет пользователю уведомление о закрытии.

### AC-7: Фронтенд-кнопка
- GIVEN: пользователь заходит в приложение
- WHEN: он видит header/footer
- THEN: там отображается кнопка `Написать в поддержку` — при клике открывается внешняя ссылка на чат бота (телеграм) или модал с инструкцией.

### AC-8: Безопасность токенов
- GIVEN: репозиторий готов к деплою
- WHEN: код проверяется
- THEN: токен бота отсутствует в репозитории и присутствует в env переменных/секретах CI.

### AC-9: Логи и метрики
- GIVEN: бот работает
- WHEN: приходят/пересылаются сообщения
- THEN: в логах присутствуют структурированные события, и метрики инкрементируются: `messages_received_total`, `messages_forwarded_total`, `responses_sent_total`, `errors_total`.

### AC-10: Восстановление после падения
- GIVEN: сервис бота упал
- WHEN: сервис рестартан (process manager/k8s)
- THEN: бот возобновляет обработку входящих сообщений; `uptime_seconds` возобновляется и нет потери критического состояния (например, незавершённые сессии — допускается in-memory потеря, но это должно быть явно указано в документации).

---

## 10. Тестовые сценарии (Gherkin)

```gherkin
Feature: Telegram support bot

  Scenario: User sends initial message and receives greeting
    Given a Telegram account
    When the user sends "привет" to @YourBot
    Then the bot replies with greeting and a session id

  Scenario: Message is forwarded to operator
    Given an operator group with id <OP_CHAT_ID>
    When a user sends "у меня вопрос" to bot
    Then the operator group receives a forwarded message containing session id and user id

  Scenario: Operator replies via reply
    Given the forwarded user message in operator chat
    When operator replies using reply with "ответ" text
    Then the user receives "ответ" from bot

  Scenario: Operator writes without reply
    When operator writes "foo" in operator chat not as reply
    Then bot sends instruction to operator: "Reply to the forwarded message to answer the user"

  Scenario: Close session
    Given an open session id
    When operator runs /close <session_id>
    Then the user receives notification that session is closed
```

---

## 11. Deliverables

1. Код бота (Node.js / Python — выбрать стек команды) с README по деплою и env variables.
2. Минимальный фронтенд: кнопка `Написать в поддержку` + модал/линейк с `tg://`/`https://t.me/<bot>`.
3. Документация: конфигурация, список env vars, как задать операторский ID, как включить webhook/polling.
4. Набор тестов по Gherkin и краткий чеклист приёмки.

---

## 12. Что явно не включено

- Встроенная база тикетов и UI для операторов в приложении.
- Историческое хранение переписок за пределами логов (если нужно — обсудить отдельно).
- Интеграции с внешними системами (Slack/HelpDesk).

---

## 13. Примечание для ИИ-агента/разработчика

- Не делать предположений о доступности webhook URL или operator IDs — требовать их у заказчика. Если заказчик не предоставил — использовать long polling и переменные окружения для операторских ID.
- Все проверки в Acceptance Criteria должны быть проверяемыми вручную и/или автоматическими. Любое отклонение — фиксировать как блокер.

---

*Конец спецификации.*

