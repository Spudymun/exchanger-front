generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email               String                @unique @db.VarChar(255)
  hashedPassword      String?               @map("hashed_password")
  isVerified          Boolean               @default(false) @map("is_verified")
  telegramId          String?               @unique @map("telegram_id") @db.VarChar(20)
  createdAt           DateTime              @default(now()) @map("created_at") @db.Timestamptz(6)
  lastLoginAt         DateTime?             @map("last_login_at") @db.Timestamptz(6)
  auditLogsPerformed  OrderAuditLog[]       @relation("AuditLogPerformer")
  operatorAssignments Order[]               @relation("OperatorAssignments")
  orders              Order[]
  sessions            Session[]
  appRoles            UserAppRole[]
  passwordResetTokens PasswordResetToken[]

  @@index([email])
  @@index([telegramId])
  @@index([createdAt])
  @@map("users")
}

model Session {
  id                 String          @id @db.VarChar(255)
  userId             String          @map("user_id") @db.Uuid
  data               Json?
  expiresAt          DateTime        @map("expires_at") @db.Timestamptz(6)
  createdAt          DateTime        @default(now()) @map("created_at") @db.Timestamptz(6)
  lastActivity       DateTime        @default(now()) @map("last_activity") @db.Timestamptz(6)
  ipAddress          String?         @map("ip_address") @db.Inet
  userAgent          String?         @map("user_agent")
  revoked            Boolean         @default(false)
  revokedAt          DateTime?       @map("revoked_at") @db.Timestamptz(6)
  applicationContext ApplicationType @default(WEB) @map("application_context")
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([applicationContext, userId])
  @@index([expiresAt])
  @@index([createdAt])
  @@index([revoked])
  @@map("sessions")
}

model PasswordResetToken {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  token     String   @unique @db.VarChar(6)
  expiresAt DateTime @map("expires_at") @db.Timestamptz(6)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  used      Boolean  @default(false)
  usedAt    DateTime? @map("used_at") @db.Timestamptz(6)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@index([used, expiresAt])
  @@map("password_reset_tokens")
}

model UserAppRole {
  id                 String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId             String          @map("user_id") @db.Uuid
  applicationContext ApplicationType @map("application_context")
  role               UserRole
  createdAt          DateTime        @default(now()) @map("created_at") @db.Timestamptz(6)
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, applicationContext])
  @@index([applicationContext])
  @@index([role])
  @@index([userId])
  @@map("user_app_roles")
}

model Order {
  id                 String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  publicId           String                   @unique @map("public_id") @db.VarChar(30)
  userId             String                   @map("user_id") @db.Uuid
  cryptoAmount       Decimal                  @map("crypto_amount") @db.Decimal(36, 18)
  currency           String                   @db.VarChar(10)
  uahAmount          Decimal                  @map("uah_amount") @db.Decimal(12, 2)
  status             OrderStatus              @default(PENDING)
  txHash             String?                  @map("tx_hash") @db.VarChar(255)
  recipientData      Json?                    @map("recipient_data")
  assignedOperatorId String?                  @map("assigned_operator_id") @db.Uuid
  assignedAt         DateTime?                @map("assigned_at") @db.Timestamptz(6)
  createdAt          DateTime                 @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt          DateTime                 @updatedAt @map("updated_at") @db.Timestamptz(6)
  processedAt        DateTime?                @map("processed_at") @db.Timestamptz(6)
  walletId           String?                  @map("wallet_id") @db.Uuid
  bankId             String?                  @map("bank_id") @db.Uuid
  fixedExchangeRate  Decimal?                 @map("fixed_exchange_rate") @db.Decimal(15, 8)
  expiresAt          DateTime?                @map("expires_at") @db.Timestamptz(6)
  auditLogs          OrderAuditLog[]
  telegramMessages   TelegramOrderMessage[]
  assignedOperator   User?                    @relation("OperatorAssignments", fields: [assignedOperatorId], references: [id])
  user               User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet             Wallet?                  @relation(fields: [walletId], references: [id])
  bank               Bank?                    @relation(fields: [bankId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
  @@index([currency])
  @@index([createdAt])
  @@index([status, createdAt])
  @@index([walletId])
  @@index([assignedOperatorId])
  @@index([txHash])
  @@index([publicId])
  @@index([bankId])
  @@index([expiresAt])
  @@index([status, expiresAt])
  @@index([userId, status], name: "idx_user_status_for_duplicate_check")
  @@map("orders")
}

model OrderAuditLog {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orderId     String   @map("order_id") @db.Uuid
  action      String   @db.VarChar(100)
  oldValue    String?  @map("old_value") @db.VarChar(100)
  newValue    String?  @map("new_value") @db.VarChar(100)
  metadata    Json?
  comment     String?
  performedBy String?  @map("performed_by") @db.Uuid
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user        User?    @relation("AuditLogPerformer", fields: [performedBy], references: [id])

  @@index([orderId])
  @@index([createdAt])
  @@index([action])
  @@index([performedBy])
  @@index([orderId, createdAt])
  @@map("order_audit_logs")
}

model Wallet {
  id            String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  address       String        @unique @db.VarChar(255)
  currency      String        @db.VarChar(10)
  tokenStandard String?       @map("token_standard") @db.VarChar(20)
  status        WalletStatus  @default(AVAILABLE)
  label         String?       @db.VarChar(100)
  notes         String?
  totalOrders   Int           @default(0) @map("total_orders")
  lastUsedAt    DateTime?     @map("last_used_at") @db.Timestamptz(6)
  createdAt     DateTime      @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt     DateTime      @updatedAt @map("updated_at") @db.Timestamptz(6)
  disabledAt    DateTime?     @map("disabled_at") @db.Timestamptz(6)
  orders        Order[]

  @@index([currency, status])
  @@index([status])
  @@index([currency])
  @@index([lastUsedAt])
  @@index([currency, status, lastUsedAt])
  @@index([createdAt])
  @@index([address])
  @@map("wallets")
}

enum UserRole {
  USER     @map("user")
  ADMIN    @map("admin")
  OPERATOR @map("operator")
  SUPPORT  @map("support")
}

enum ApplicationType {
  WEB   @map("web")
  ADMIN @map("admin")
}

enum OrderStatus {
  PENDING    @map("pending")
  PAID       @map("paid")
  PROCESSING @map("processing")
  COMPLETED  @map("completed")
  CANCELLED  @map("cancelled")
  FAILED     @map("failed")
}

enum WalletStatus {
  AVAILABLE @map("available")
  ALLOCATED @map("allocated")
  DISABLED  @map("disabled")
}

model Bank {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  externalId String   @unique @map("external_id") @db.VarChar(50)
  name       String   @db.VarChar(100)
  shortName  String   @map("short_name") @db.VarChar(50)
  logoUrl    String?  @map("logo_url") @db.VarChar(255)
  isActive   Boolean  @default(true) @map("is_active")
  isDefault  Boolean  @default(false) @map("is_default")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  fiatCurrencies BankFiatCurrency[]
  reserves       BankReserve[]
  orders         Order[]

  @@index([externalId])
  @@index([isActive, isDefault])
  @@map("banks")
}

model BankFiatCurrency {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  bankId       String   @map("bank_id") @db.Uuid
  fiatCurrency String   @map("fiat_currency") @db.VarChar(10)
  minAmount    Decimal  @default(100) @map("min_amount") @db.Decimal(12, 2)
  maxAmount    Decimal  @default(100000) @map("max_amount") @db.Decimal(12, 2)
  isEnabled    Boolean  @default(true) @map("is_enabled")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  bank Bank @relation(fields: [bankId], references: [id], onDelete: Cascade)

  @@unique([bankId, fiatCurrency])
  @@index([fiatCurrency, isEnabled])
  @@map("bank_fiat_currencies")
}

model BankReserve {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  bankId       String   @map("bank_id") @db.Uuid
  fiatCurrency String   @map("fiat_currency") @db.VarChar(10)
  amount       Decimal  @default(0) @db.Decimal(15, 2)
  lastUpdated  DateTime @default(now()) @map("last_updated") @db.Timestamptz(6)

  bank Bank @relation(fields: [bankId], references: [id], onDelete: Cascade)

  @@unique([bankId, fiatCurrency])
  @@index([fiatCurrency, amount])
  @@map("bank_reserves")
}

model TelegramOrderMessage {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orderId          String   @map("order_id") @db.Uuid
  chatId           String   @map("chat_id") @db.Text
  messageId        BigInt   @map("message_id")
  topicId          Int?     @map("topic_id")
  notificationType String   @map("notification_type") @db.Text
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@unique([orderId, notificationType], name: "telegram_order_message_unique")
  @@index([orderId])
  @@index([chatId, messageId], name: "idx_telegram_chat_message")
  @@map("telegram_order_messages")
}

/// Manual Exchange Rates
/// Ручные курсы для fallback когда P2P API недоступен
/// Используется как Manual Fallback в иерархии: P2P → Cache → Manual DB → Error
model ManualExchangeRate {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  currency    String   @db.Text // 'USDT', 'BTC', 'ETH', 'LTC'
  uahRate     Decimal  @map("uah_rate") @db.Decimal(18, 2) // Курс UAH за 1 единицу крипты
  isActive    Boolean  @default(true) @map("is_active") // Активен ли курс
  validUntil  DateTime @map("valid_until") @db.Timestamptz(6) // Действителен до (для проверки устаревания)
  createdBy   String   @map("created_by") @db.Text // Email администратора
  comment     String?  @db.Text // Комментарий причины установки курса
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@unique([currency, isActive], name: "manual_rate_active_unique")
  @@index([currency])
  @@index([isActive])
  @@index([validUntil])
  @@map("manual_exchange_rates")
}
